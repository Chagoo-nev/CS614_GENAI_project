"""
Utility functions for model operations including generation and answer checking.
"""

import torch
import re

def generate_solution(model, tokenizer, prompt, max_new_tokens=728):
    """
    Generate a solution for a math problem, ensuring stability and avoiding randomness.
    """
    # Tokenize input
    inputs = tokenizer(prompt, return_tensors="pt").to(model.device)

    # Record inference time
    start_time = torch.cuda.Event(enable_timing=True)
    end_time = torch.cuda.Event(enable_timing=True)

    start_time.record()

    # Key optimization: Use greedy decoding to avoid randomness
    with torch.no_grad():
        outputs = model.generate(
            **inputs,
            max_new_tokens=max_new_tokens,
            temperature=0.0,  # Set to 0 to avoid randomness
            do_sample=False,  # Disable random sampling
            repetition_penalty=1.2  # Prevent meaningless repetition
        )

    end_time.record()
    torch.cuda.synchronize()
    inference_time = start_time.elapsed_time(end_time) / 1000  # Convert to seconds

    # Parse model output
    generated_text = tokenizer.decode(outputs[0], skip_special_tokens=True)
    solution = generated_text[len(prompt):]

    return solution, inference_time


import re

def extract_numeric_answer(answer_text):
    """
    Extract the numeric value after `####` from a given text.
    
    Args:
        answer_text (str): The answer text which contains the number after `####`
    
    Returns:
        float or None: Extracted numerical value, or None if not found
    """
    match = re.search(r'####\s*(-?\d+\.?\d*)', answer_text)
    return float(match.group(1)) if match else None


def check_answer_directly(generated_solution, reference_answer):
    """
    Directly compare the numeric value after `####`. If it matches, return True; otherwise, return False.
    
    Args:
        generated_solution (str): Answer generated by Llama-3.1-8B
        reference_answer (str): Correct answer from the GSM8K dataset
    
    Returns:
        bool: Whether the answers match
    """
    # 1. Extract reference and predicted answers
    ref_answer = extract_numeric_answer(reference_answer)
    pred_answer = extract_numeric_answer(generated_solution)
    
    # 2. If either value is None, return False
    if ref_answer is None or pred_answer is None:
        return False
    
    # 3. Direct numerical comparison
    return pred_answer == ref_answer  # 自动忽略 18 vs 18.0 的问题


# def check_answer_with_model(checker_model, checker_tokenizer, generated_solution, reference_answer, question):
#     """
#     First, attempt to compare numeric values directly. If they match, return True. Otherwise, invoke the Instruct model for verification.
#     """
#     # First, attempt direct numeric comparison
#     if check_answer_directly(generated_solution, reference_answer):
#         return True, 0  # Return correct immediately, skipping the Instruct model

#     # device = model.device
    
#     # If direct comparison fails, invoke the Instruct model
#     checker_prompt = f"""As a math evaluator, determine if the solution to the problem is correct.

# PROBLEM:
# {question}

# CORRECT ANSWER:
# {reference_answer}

# STUDENT SOLUTION:
# {generated_solution}

# Determine if the student arrived at the correct answer.
# Reply with 'CORRECT' or 'INCORRECT' only.
# """

#     # Tokenize checker prompt
#     inputs = checker_tokenizer(checker_prompt, return_tensors="pt").to(checker_model.device)

#     # Record Checker computation time
#     start_time = torch.cuda.Event(enable_timing=True)
#     end_time = torch.cuda.Event(enable_timing=True)

#     start_time.record()

#     # Generate Checker output
#     with torch.no_grad():
#         outputs = checker_model.generate(
#             **inputs,
#             max_new_tokens=20,
#             temperature=0.1,  # Low temperature for stability
#             do_sample=False  # Disable randomness
#         )

#     end_time.record()
#     torch.cuda.synchronize()
#     check_time = start_time.elapsed_time(end_time) / 1000  # Convert to seconds

#     # Parse checker output
#     evaluation = checker_tokenizer.decode(outputs[0], skip_special_tokens=True)
#     evaluation = evaluation[len(checker_prompt):].strip()

#     # **Ensure formatted answer correctly matches**
#     is_correct = "CORRECT" in evaluation.upper()

#     return is_correct, check_time


def test_models(main_model, main_tokenizer):
    """
    Test whether the models function correctly and generate text properly.
    """
    try:
        # Auto-detect device
        device = "cuda" if torch.cuda.is_available() else "cpu"

        # Test the main model
        test_input = "What is 2+2?"
        print(f"Testing main model on: '{test_input}'")
        inputs = main_tokenizer(test_input, return_tensors="pt").to(device)
        
        with torch.no_grad():
            outputs = main_model.generate(**inputs, max_new_tokens=50)
        
        test_output = main_tokenizer.decode(outputs[0], skip_special_tokens=True)
        print(f" Main model output: {test_output}")

    except Exception as e:
        print(f" Error testing main model: {e}")

    try:
        # Test the checker model
        test_input = "Verify if this math answer is correct: 2+2=4"
        print(f"\nTesting checker model on: '{test_input}'")
        inputs = checker_tokenizer(test_input, return_tensors="pt").to(device)

        with torch.no_grad():
            outputs = checker_model.generate(**inputs, max_new_tokens=50)

        test_output = checker_tokenizer.decode(outputs[0], skip_special_tokens=True)
        print(f" Checker model output: {test_output}")

    except Exception as e:
        print(f" Error testing checker model: {e}")

    print("\nModel tests completed successfully.")



def extract_numeric_answer(answer_text):
    """
    从 GSM8K 数据集中提取 `####` 之后的正确答案。

    Args:
        answer_text: 包含答案的文本

    Returns:
        str: 提取出的数值答案，或者 None 如果未找到
    """
    # GSM8K 数据格式是 "#### 数字"
    ref_match = re.search(r'####\s*(-?[\d.]+)', answer_text)
    if ref_match:
        return ref_match.group(1)
    
    # 兼容其他格式，如 "FINAL ANSWER: 12"
    final_answer_match = re.search(r'FINAL ANSWER:\s*(-?[\d.]+)', answer_text, re.IGNORECASE)
    if final_answer_match:
        return final_answer_match.group(1)
    
    # 最后尝试匹配任何数字
    numbers = re.findall(r'-?[\d.]+', answer_text)
    return numbers[-1] if numbers else None
